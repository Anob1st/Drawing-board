<canvas id="board" width="800" height="650" style="border:2px solid black;"></canvas>
<br>
<input type="color" id="color" value="#000000">
<input type="range" id="size" min="1" max="30" value="5">
<button id="undo">Undo</button>
<button id="clear">Clear</button>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const color = document.getElementById("color");
const size = document.getElementById("size");
const undoBtn = document.getElementById("undo");
const clearBtn = document.getElementById("clear");

let drawing = false;
let lastX = 0, lastY = 0;
let lastTime = 0;
let history = [];

// Save canvas state for undo
function saveState() {
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  history.push(imgData);
  if(history.length>50) history.shift();
}

// Restore canvas state
function restoreState() {
  if(history.length>0){
    ctx.putImageData(history[history.length-1],0,0);
  } else {
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }
}

// Get position relative to canvas
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  if(e.touches) return {x:e.touches[0].clientX - rect.left, y:e.touches[0].clientY - rect.top};
  return {x:e.offsetX, y:e.offsetY};
}

// Start drawing
function startDraw(pos){
  drawing = true;
  lastX = pos.x;
  lastY = pos.y;
  lastTime = Date.now();
}

// Draw line with fast-thin / slow-thick effect
function draw(pos){
  if(!drawing) return;
  const now = Date.now();
  const dt = now - lastTime || 1;
  const dist = Math.sqrt((pos.x-lastX)**2 + (pos.y-lastY)**2);
  const speed = dist/dt;

  // Slight fast-thin, slow-thick effect
  const baseSize = parseInt(size.value);
  const dynamicSize = Math.max(1, baseSize * Math.min(2, 2 - speed*0.02));

  ctx.strokeStyle = color.value;
  ctx.lineWidth = dynamicSize;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(lastX,lastY);
  ctx.lineTo(pos.x,pos.y);
  ctx.stroke();

  lastX = pos.x;
  lastY = pos.y;
  lastTime = now;
}

// Stop drawing
function stopDraw(pos){
  if(!drawing) return;
  draw(pos);
  drawing = false;
  saveState();
}

// Mouse events
canvas.addEventListener("mousedown", e=>startDraw(getPos(e)));
canvas.addEventListener("mousemove", e=>draw(getPos(e)));
canvas.addEventListener("mouseup", e=>stopDraw(getPos(e)));
canvas.addEventListener("mouseout", e=>stopDraw(getPos(e)));

// Touch events
canvas.addEventListener("touchstart", e=>{ e.preventDefault(); startDraw(getPos(e)); });
canvas.addEventListener("touchmove", e=>{ e.preventDefault(); draw(getPos(e)); });
canvas.addEventListener("touchend", e=>stopDraw(lastX,lastY));

// Buttons
undoBtn.onclick = () => { if(history.length>0){ history.pop(); restoreState(); } };
clearBtn.onclick = () => { ctx.clearRect(0,0,canvas.width,canvas.height); saveState(); };
</script>
